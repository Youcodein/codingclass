<div class="document">
  <h2 class="t_tit" data-ke-size="size26">
    Programmers Lv.1 : 최대공약수와 최소공배수
  </h2>
  <p class="t_desc2" data-ke-size="size16">
    두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다.
  </p>
  <p class="t_desc2" data-ke-size="size16">
    두 수는 1이상 1000000이하의 자연수입니다.
  </p>
  <h2 class="t_tit" data-ke-size="size26">내 풀이</h2>
  <div class="t_code">
<pre class="javascript"><code>process.stdin.setEncoding('utf8');
  process.stdin.on('data', data => {
      const n = data.split(" ");
      const a = Number(n[0]), b = Number(n[1]);
  
  let result="";
  
  for(let i = 0; i&lt; b; i++){
    for(let j=0; j&lt;a; j++){
      result += "*";
    }
    result += "\n";
  }
  
  console.log(result);
  });
</code></pre>
  </div>
  <p class="t_box">
    가로줄의 별을 반복문으로 먼저 만들고, 이후 세로줄의 별을 만드는 반복문("\n") 을 만들어준다.
  </p>
  <!-- 내 풀이 -->

  <h2 class="t_tit" data-ke-size="size26">다른 사람들의 풀이</h2>
  <div class="t_code">
<pre class="javascript"><code>process.stdin.setEncoding('utf8');
  process.stdin.on('data', data => {
      const n = data.split(" ");
      const a = Number(n[0]), b = Number(n[1]);
      const row = '*'.repeat(a)
      for(let i =0; i &lt; b; i++){
          console.log(row)
      }
    
    // 또 다른 방법
      const star = `${'*'.repeat(a)}\n`;
      console.log(star.repeat(b));
  
  });
</code></pre>
  </div>
  <!-- <p class="t_box">filter()와 삼항연산자 사용</p> -->
</div>
